// MDL v1 utf8
mevislabVersion = 3.4.2
network  {
  watchlist = ""
}
module View2D {
  internal  {
    frame = "205 666 120 56"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "1402 301 400 400"
        sizeHint = "400 400"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = View2D5
    inventorInputOn = TRUE
    inventorOutputOn = FALSE
    view2DExtensionsOn = TRUE
    startSlice = 0
    numSlices = 1
    numXSlices = 1
    sliceStep = 1
    slab = 1
    blendMode = BLEND_REPLACE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    standardKeys = TRUE
    cineMode = CINE_ZT
    cineDirection = CINE_FORWARD
    cineRepeat = CINE_ONCE
    cineSpeed = 0.1
    cineAlwaysReset = TRUE
    snapToCenter = TRUE
    zoomMode = VIEW2D_AUTO_ZOOM
    unzoomOnImageChange = FALSE
    sliceZoom = 1
    sliceZoomSynced = 1
    baseColor = "1 1 1"
    margin = "2 2"
    sliceOrigin = "0 0"
    useShaders = TRUE
    useManagedInteraction = FALSE
    lutCenter = 127.5
    lutWidth = 255
    annotationOn = TRUE
    annotationMode = ANNO_MODE_AUTO
    annotationSizeMode = ANNO_SHOW_DETAILED
    annotationCol = "0.899999976158142 0.899999976158142 0.899999976158142"
    annotationFontSize = ANNO_SIZE_AUTO
    annoCoords = Voxel
    annoCTValue = AsIs
    borderOn = FALSE
    borderColor = "0.899999976158142 0.899999976158142 0.899999976158142"
    valueHighPrecision = TRUE
    showColorChannelValues = FALSE
    colorChannelSeparator = " / "
    maxPrecision = 4
    enableSlicing = TRUE
    useRelativeLUTIfNoInputImage = TRUE
  }
}
module PythonArithmetic {
  internal  {
    frame = "201 782 128 64"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "797 222 903 776"
        sizeHint = "571 528"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = CircleDrawer
    calculateOutputSubImage = "
# Create the Numpy matrix
out = numpy.zeros((128, 128))
extent=128

# We want to create a circle with a thickness of about 4. So we draw two circles with a radius difference of 4
thickness = 4
r1 = 30
r2 = r1 - thickness

def drawCircle(extent, radius):
  Image = numpy.zeros((extent, extent))
  for y in range(0,extent):
    for x in range(0,extent):
      if (x-64)**2+(y-64)**2 < radius**2:
        Image[x,y] = 255
  return Image
  
# Draw the outer circle
outer_circle = drawCircle(extent, r1)

# And the inner one
inner_circle = drawCircle(extent, r2)

# and then?
out = outer_circle - inner_circle "
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = "extent = 128
outImage.setImageExtent(extent,extent,1)
outImage.setPageExtent(extent,extent,1)
outImage.setMinVoxelValue(0)
outImage.setMaxVoxelValue(255)"
    numberOfInputs = 0
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = TRUE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module View2D {
  internal  {
    frame = "367 669 120 56"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "214 397 400 400"
        sizeHint = "400 400"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = View2D4
    inventorInputOn = TRUE
    inventorOutputOn = FALSE
    view2DExtensionsOn = TRUE
    startSlice = 63
    numSlices = 1
    numXSlices = 1
    sliceStep = 1
    slab = 1
    blendMode = BLEND_REPLACE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    standardKeys = TRUE
    cineMode = CINE_ZT
    cineDirection = CINE_FORWARD
    cineRepeat = CINE_ONCE
    cineSpeed = 0.1
    cineAlwaysReset = TRUE
    snapToCenter = TRUE
    zoomMode = VIEW2D_AUTO_ZOOM
    unzoomOnImageChange = FALSE
    sliceZoom = 1
    sliceZoomSynced = 1
    baseColor = "1 1 1"
    margin = "2 2"
    sliceOrigin = "0 0"
    useShaders = TRUE
    useManagedInteraction = FALSE
    lutCenter = 127.5
    lutWidth = 255
    annotationOn = TRUE
    annotationMode = ANNO_MODE_AUTO
    annotationSizeMode = ANNO_SHOW_DETAILED
    annotationCol = "0.899999976158142 0.899999976158142 0.899999976158142"
    annotationFontSize = ANNO_SIZE_AUTO
    annoCoords = Voxel
    annoCTValue = AsIs
    borderOn = FALSE
    borderColor = "0.899999976158142 0.899999976158142 0.899999976158142"
    valueHighPrecision = TRUE
    showColorChannelValues = FALSE
    colorChannelSeparator = " / "
    maxPrecision = 4
    enableSlicing = TRUE
    useRelativeLUTIfNoInputImage = TRUE
  }
}
module PythonArithmetic {
  internal  {
    frame = "363 785 128 64"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "893 219 842 691"
        sizeHint = "571 528"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = SphereDrawer
    calculateOutputSubImage = "
# Create the Numpy matrix
out = numpy.zeros((128, 128, 128))
extent = 128
# We want to create a sphere with a thickness of about 4. So we draw two spheres with a radius difference of 4
thickness = 4
r1 = 30
r2 = r1 - thickness

# Do not forget to re-use part of your code from CircleDrawer
def drawSphere(extent, radius):
  Image = numpy.zeros((extent, extent, extent)) 
  for z in range(0,extent):
    for y in range(0,extent):
      for x in range(0,extent):
        if (x-64)**2+(y-64)**2+(z-64)**2 < radius**2:
          Image[x,y,z] = 255
  return Image
  
# Draw the outer sphere
outer_circle = drawSphere(extent, r1)

# And the inner one
inner_circle = drawSphere(extent, r2)

# And combine both sphere to create the hollow sphere
out = outer_circle - inner_circle"
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = "extent = 128
outImage.setImageExtent(extent,extent,extent)
outImage.setPageExtent(extent,extent,extent)
outImage.setMinVoxelValue(0)
outImage.setMaxVoxelValue(255)"
    numberOfInputs = 0
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = TRUE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module View3D {
  internal  {
    frame = "497 597 144 56"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "-59 289 1187 644"
        sizeHint = "1187 644"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = View3D
    autoViewAll = TRUE
    inventorInputOn = TRUE
    inventorOutputOn = FALSE
    lutType = Ramp
    rendererType = Slicer
    currentTimePoint = 0
    staticSamplingRate = 1
    quality = 1
    filterVolumeData = FilterLinear
    lutEditorColorPoints = "[ 0 0 0 0, 4095 1 1 1 ]"
    lutEditorAlphaPoints = "[ 0 0, 4095 1 ]"
    lutEditorRelativeLut = FALSE
    lutEditorColorInterpolation = InterpolateRGB
    lutEditorAlphaFactor = 1
    orientationProjectionType = PERSPECTIVE
    orientationLocation = LOWER_RIGHT
    orientationOn = TRUE
    orientationModel = CUBE
    greyCenter = 0.5
    greyWidth = 0.5
    alphaFactor = 1
    colorFactor = "1 1 1"
    camType = TRUE
    camPosition = "326.117370605469 186.547073364258 25.2623710632324"
    camOrientation = "-0.698642492294312 0.641957700252533 -0.315893918275833 1.83201098442078"
    initialCameraOrientation = CAMERA_KEEP_AS_IS
    camFar = 385.86423
    camNear = 198.1855
    camFocal = 291.93137
    camHeight = 0.78539801
    decoration = FALSE
    annotations = TRUE
    background = TRUE
    mode = VolumeRendering
    interactiveQuality = Medium
  }
  internalFields  {
    renderer.gradientQuality = GradientQualityAutomatic
    renderer.enhancementAlphaMix = 0.25
    renderer.boundaryEnhancement = FALSE
    renderer.boundaryEnhancementFactor = 1
    renderer.boundaryEnhancementExponent = 1
    renderer.boundaryEnhancementGradientBias = 0
    renderer.silhouetteEnhancement = FALSE
    renderer.silhouetteEnhancementExponent = 1
    renderer.silhouetteEnhancementFactor = 1
    renderer.toneShading = FALSE
    renderer.toneShadingWarmColor = "0.67451000213623 0.533333003520966 0.141176000237465"
    renderer.toneShadingColdColor = "0 0 0.400000005960464"
    renderer.toneShadingWarmDiffuse = 0.60000002
    renderer.toneShadingColdDiffuse = 0.2
    renderer.toneShadingAngle = 45
    renderer.materialAmbient = 0.60000002
    renderer.materialDiffuse = 1
    renderer.materialSpecular = 1
    renderer.materialSpecularity = 32
    renderer.light1Enabled = TRUE
    renderer.light1DiffuseIntensity = 1
    renderer.light1SpecularIntensity = 1
    renderer.light1Color = "1 1 1"
    renderer.light1PolarPhi = 45
    renderer.light1PolarRho = 0
    renderer.light2Enabled = FALSE
    renderer.light2DiffuseIntensity = 1
    renderer.light2SpecularIntensity = 1
    renderer.light2Color = "1 1 1"
    renderer.light2PolarPhi = 0
    renderer.light2PolarRho = 0
    renderer.light3Enabled = FALSE
    renderer.light3DiffuseIntensity = 1
    renderer.light3SpecularIntensity = 1
    renderer.light3Color = "1 1 1"
    renderer.light3PolarPhi = -45
    renderer.light3PolarRho = 0
    renderer.sizeOutputX = 128
    renderer.sizeOutputY = 128
    renderer.sizeOutputZ = 128
    renderer.subVolumeStartX = 0
    renderer.subVolumeStartY = 0
    renderer.subVolumeStartZ = 0
    renderer.subVolumeEndX = 128
    renderer.subVolumeEndY = 128
    renderer.subVolumeEndZ = 128
    clip.hideGeometry = FALSE
    clip.on = FALSE
    clip.left = FALSE
    clip.right = FALSE
    clip.top = FALSE
    clip.bottom = FALSE
    clip.rear = FALSE
    clip.front = FALSE
    clip.translation0 = "1 0 0"
    clip.translation1 = "-1 0 0"
    clip.translation2 = "0 1 0"
    clip.translation3 = "0 -1 0"
    clip.translation4 = "0 0 1"
    clip.translation5 = "0 0 -1"
    clip.rotation0 = "0 0 0.999999940395355 1.57079994678497"
    clip.rotation1 = "0 0 -0.999999940395355 1.57079994678497"
    clip.rotation2 = "0 0 -1 3.1415901184082"
    clip.rotation3 = "0 0 1 0"
    clip.rotation4 = "-0.999999940395355 0 0 1.57079994678497"
    clip.rotation5 = "0.999999940395355 0 0 1.57079994678497"
  }
}
module PythonArithmetic {
  internal  {
    frame = "725 789 136 56"
    moduleGroupName = "Exercise 2.2"
    windows  {
      window _default {
        geometry = "1041 272 796 528"
        sizeHint = "571 528"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = PythonArithmetic1
    calculateOutputSubImage = "*import os
import importlib.util
from mevis import *

# ctx is the MeVisLab context variable, which lets you fetch and modify the current network. See the reference: https://mevislabdownloads.mevis.de/docs/2.7.1/MeVisLab/Resources/Documentation/Publish/SDK/ScriptingReference/classMLABModule.html
# (Scroll down to "Detailed Description")

# Obtain current network path and convert to full (absolute) path
absPath = os.path.abspath(ctx.networkPath())

# Use the python import utility to import the module.
spec = importlib.util.spec_from_file_location("Interpolation", os.path.join(absPath, "Interpolation.py"))

Interpolation = importlib.util.module_from_spec(spec)
spec.loader.exec_module(Interpolation)


import numpy as np

def square2coords(square):
    return square[0, 0], square[0, 1], square[1, 0], square[1, 1]

def test(expected, fun, args):
    actual = fun(*args)
    success = actual == expected
    print(f"Test {'PASSED' if success else 'FAILED'}: Expected: {expected} {'equals' if success else 'but was'} {actual} ")


square0 = np.array([
        [1.0, 1.0], 
        [1.0, 1.0]
])

square1 = np.array([
        [0.0, 1.0], 
        [2.0, 3.0]
])

square2 = np.array([
        [4.0, 6.0], 
        [8.0, 13.0]
])

x00, x01, x10, x11 = square2coords(square1)
y00, y01, y10, y11 = square2coords(square2)

print("\\nTest Linear Interp")

test(x00, Interpolation.linear_interp, (x00, x01, 0.0))
test(x01, Interpolation.linear_interp, (x00, x01, 1.0))
test((x00 + x01) * 0.5, Interpolation.linear_interp, (x00, x01, 0.5))

print("\\nTest Bilinear Interp corners")

# Test the four corners of square1
test(x00, Interpolation.bilinear_interp, (x00, x01, x10, x11, 0.0, 0.0))
test(x01, Interpolation.bilinear_interp, (x00, x01, x10, x11, 1.0, 0.0))
test(x10, Interpolation.bilinear_interp, (x00, x01, x10, x11, 0.0, 1.0))
test(x11, Interpolation.bilinear_interp, (x00, x01, x10, x11, 1.0, 1.0))

# Test the middle-point
test(np.mean(square1), Interpolation.bilinear_interp, (x00, x01, x10, x11, 0.5, 0.5))

print("\\nTest Trilinear Interp corners")

# Test the 8 corners of square1 and square2
test(x00, Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 0.0, 0.0, 0.0))
test(x01, Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 1.0, 0.0, 0.0))
test(x10, Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 0.0, 1.0, 0.0))
test(x11, Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 1.0, 1.0, 0.0))

test(y00, Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 0.0, 0.0, 1.0))
test(y01, Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 1.0, 0.0, 1.0))
test(y10, Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 0.0, 1.0, 1.0))
test(y11, Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 1.0, 1.0, 1.0))

# Test the middle-point
test(np.mean([square1, square2]), Interpolation.trilinear_interp, (x00, x01, x10, x11, y00, y01, y10, y11, 0.5 , 0.5, 0.5))*"
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = "extent = 128
outImage.setImageExtent(extent,extent,extent)
outImage.setPageExtent(extent,extent,extent)
outImage.setMinVoxelValue(0)
outImage.setMaxVoxelValue(255)"
    numberOfInputs = 0
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = TRUE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module View2D {
  internal  {
    frame = "732 678 120 56"
    moduleGroupName = "Exercise 2.2"
    windows  {
      window _default {
        geometry = "513 210 400 400"
        sizeHint = "400 400"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = View2D1
    inventorInputOn = TRUE
    inventorOutputOn = FALSE
    view2DExtensionsOn = TRUE
    startSlice = 64
    numSlices = 1
    numXSlices = 1
    sliceStep = 1
    slab = 1
    blendMode = BLEND_REPLACE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    standardKeys = TRUE
    cineMode = CINE_ZT
    cineDirection = CINE_FORWARD
    cineRepeat = CINE_ONCE
    cineSpeed = 0.1
    cineAlwaysReset = TRUE
    snapToCenter = TRUE
    zoomMode = VIEW2D_AUTO_ZOOM
    unzoomOnImageChange = FALSE
    sliceZoom = 1
    sliceZoomSynced = 1
    baseColor = "1 1 1"
    margin = "2 2"
    sliceOrigin = "0 0"
    useShaders = TRUE
    useManagedInteraction = FALSE
    lutCenter = 127.5
    lutWidth = 255
    annotationOn = TRUE
    annotationMode = ANNO_MODE_AUTO
    annotationSizeMode = ANNO_SHOW_DETAILED
    annotationCol = "0.899999976158142 0.899999976158142 0.899999976158142"
    annotationFontSize = ANNO_SIZE_AUTO
    annoCoords = Voxel
    annoCTValue = AsIs
    borderOn = FALSE
    borderColor = "0.899999976158142 0.899999976158142 0.899999976158142"
    valueHighPrecision = TRUE
    showColorChannelValues = FALSE
    colorChannelSeparator = " / "
    maxPrecision = 4
    enableSlicing = TRUE
    useRelativeLUTIfNoInputImage = TRUE
  }
}
module IsoSurface {
  internal  {
    frame = "521 693 128 56"
    moduleGroupName = "Exercise 2.1"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "1397 139 432 336"
        sizeHint = "432 336"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = IsoSurface
    isoValue = 1
    quality = 1
    useInterpolation = FALSE
    useSmoothing = FALSE
    smoothingPasses = 5
    smoothingFactor = 0.2
    usePolygonReduction = FALSE
    targetReduction = 70
    autoUpdate = TRUE
    autoApply = TRUE
    selectedTab = 0
  }
}
connections  {
  View2D5.inImage = CircleDrawer.output0
  View2D4.inImage = SphereDrawer.output0
  View3D.inImage = SphereDrawer.output0
  View3D.inInvPreLUT = IsoSurface.outScene
  View2D1.inImage = PythonArithmetic1.output0
  IsoSurface.inImage = SphereDrawer.output0
}
networkModel  {
  parentItems  {
    0  {
      MLABNetworkModelItem MLABNetworkModelItemGroup {
        uniqueId = 37
        objectName = "Exercise 2.1"
        parentUniqueId = 0
        color  {
          r = 45
          g = 226
          b = 226
          a = 40
        }
      }
      MLABNetworkModelItem MLABNoteItem {
        uniqueId = 31
        objectName = ""
        parentUniqueId = 0
        frame = "896 627 200 200"
        backgroundColor  {
          r = 252
          g = 242
          b = 2
          a = 255
        }
        text = "The PythonArithmetic module on the left here runs a set of tests for your Interpolation code. You will have to edit the Interpolation.py file. The module here imports your functions using the technique from the PythonScope assignment."
        richText = "*<html>
  <head>
    <style type="text/css">
      a.headerlink {
        visibility: hidden;
      }
      table {
        border-collapse: collapse;
      }
    </style>
  </head>
  <body>

  <p>The PythonArithmetic module on the left here runs a set of tests for your Interpolation code. You will have to edit the Interpolation.py file. The module here imports your functions using the technique from the PythonScope assignment.</p>


  </body>
</html>*"
        titleText = "Exercise 2.2"
        isCollapsed = False
        drawAsComment = False
        titleFrame = "901 632 190 22"
      }
      MLABNetworkModelItem MLABNetworkModelItemGroup {
        uniqueId = 39
        objectName = "Exercise 2.2"
        parentUniqueId = 0
        color  {
          r = 45
          g = 226
          b = 226
          a = 40
        }
      }
    }
  }
}
