// MDL v1 utf8
mevislabVersion = 3.4.2
network  {
  watchlist = ""
}
module PythonArithmetic {
  internal  {
    frame = "857 209 128 64"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "797 222 903 776"
        sizeHint = "571 528"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = CircleDrawer
    calculateOutputSubImage = "
# Create the Numpy matrix
out = numpy.zeros((128, 128))
extent=128

# We want to create a circle with a thickness of about 4. So we draw two circles with a radius difference of 4
thickness = 4
r1 = 30
r2 = r1 - thickness

def drawCircle(extent, radius):
  Image = numpy.zeros((extent, extent))
  for y in range(0,extent):
    for x in range(0,extent):
      if (x-64)**2+(y-64)**2 < radius**2:
        Image[x,y] = 255
  return Image
  
# Draw the outer circle
outer_circle = drawCircle(extent, r1)

# And the inner one
inner_circle = drawCircle(extent, r2)

# and then?
out = outer_circle - inner_circle "
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = "extent = 128
outImage.setImageExtent(extent,extent,1)
outImage.setPageExtent(extent,extent,1)
outImage.setMinVoxelValue(0)
outImage.setMaxVoxelValue(255)"
    numberOfInputs = 0
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = TRUE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module View2D {
  internal  {
    frame = "984 -85 120 56"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "214 397 400 400"
        sizeHint = "400 400"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = View2D4
    inventorInputOn = TRUE
    inventorOutputOn = FALSE
    view2DExtensionsOn = TRUE
    startSlice = 64
    numSlices = 1
    numXSlices = 1
    sliceStep = 1
    slab = 1
    blendMode = BLEND_REPLACE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    standardKeys = TRUE
    cineMode = CINE_ZT
    cineDirection = CINE_FORWARD
    cineRepeat = CINE_ONCE
    cineSpeed = 0.1
    cineAlwaysReset = TRUE
    snapToCenter = TRUE
    zoomMode = VIEW2D_AUTO_ZOOM
    unzoomOnImageChange = FALSE
    sliceZoom = 1
    sliceZoomSynced = 1
    baseColor = "1 1 1"
    margin = "2 2"
    sliceOrigin = "0 0"
    useShaders = TRUE
    useManagedInteraction = FALSE
    lutCenter = 127.5
    lutWidth = 255
    annotationOn = TRUE
    annotationMode = ANNO_MODE_AUTO
    annotationSizeMode = ANNO_SHOW_DETAILED
    annotationCol = "0.899999976158142 0.899999976158142 0.899999976158142"
    annotationFontSize = ANNO_SIZE_AUTO
    annoCoords = Voxel
    annoCTValue = AsIs
    borderOn = FALSE
    borderColor = "0.899999976158142 0.899999976158142 0.899999976158142"
    valueHighPrecision = TRUE
    showColorChannelValues = FALSE
    colorChannelSeparator = " / "
    maxPrecision = 4
    enableSlicing = TRUE
    useRelativeLUTIfNoInputImage = TRUE
  }
}
module PythonArithmetic {
  internal  {
    frame = "1020 215 128 64"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "893 219 842 691"
        sizeHint = "571 528"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = SphereDrawer
    calculateOutputSubImage = "
# Create the Numpy matrix
out = numpy.zeros((128, 128, 128))
extent = 128
# We want to create a sphere with a thickness of about 4. So we draw two spheres with a radius difference of 4
thickness = 4
r1 = 30
r2 = r1 - thickness

# Do not forget to re-use part of your code from CircleDrawer
def drawSphere(extent, radius):
  Image = numpy.zeros((extent, extent, extent)) 
  for z in range(0,extent):
    for y in range(0,extent):
      for x in range(0,extent):
        if (x-64)**2+(y-64)**2+(z-64)**2 < radius**2:
          Image[x,y,z] = 255
  return Image
  
# Draw the outer sphere
outer_circle = drawSphere(extent, r1)

# And the inner one
inner_circle = drawSphere(extent, r2)

# And combine both sphere to create the hollow sphere
out = outer_circle - inner_circle"
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = "extent = 128
outImage.setImageExtent(extent,extent,extent)
outImage.setPageExtent(extent,extent,extent)
outImage.setMinVoxelValue(0)
outImage.setMaxVoxelValue(255)"
    numberOfInputs = 0
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = TRUE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module View3D {
  internal  {
    frame = "1193 -115 144 56"
    moduleGroupName = "Exercise 2.1"
    windows  {
      window _default {
        geometry = "465 327 1187 644"
        sizeHint = "1187 644"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = View3D
    autoViewAll = TRUE
    inventorInputOn = TRUE
    inventorOutputOn = FALSE
    lutType = Ramp
    rendererType = Slicer
    currentTimePoint = 0
    staticSamplingRate = 1
    quality = 1
    filterVolumeData = FilterLinear
    lutEditorColorPoints = "[ 0 0 0 0, 4095 1 1 1 ]"
    lutEditorAlphaPoints = "[ 0 0, 4095 1 ]"
    lutEditorRelativeLut = FALSE
    lutEditorColorInterpolation = InterpolateRGB
    lutEditorAlphaFactor = 1
    orientationProjectionType = PERSPECTIVE
    orientationLocation = LOWER_RIGHT
    orientationOn = TRUE
    orientationModel = CUBE
    greyCenter = 0.5
    greyWidth = 0.5
    alphaFactor = 1
    colorFactor = "1 1 1"
    camType = TRUE
    camPosition = "184.383148193359 120.548645019531 46.7827987670898"
    camOrientation = "-0.698642492294312 0.641957700252533 -0.315893918275833 1.83201098442078"
    initialCameraOrientation = CAMERA_KEEP_AS_IS
    camFar = 176.48055
    camNear = 90.642982
    camFocal = 133.51898
    camHeight = 0.78539801
    decoration = FALSE
    annotations = TRUE
    background = TRUE
    mode = VolumeRendering
    interactiveQuality = Medium
  }
  internalFields  {
    renderer.gradientQuality = GradientQualityAutomatic
    renderer.enhancementAlphaMix = 0.25
    renderer.boundaryEnhancement = FALSE
    renderer.boundaryEnhancementFactor = 1
    renderer.boundaryEnhancementExponent = 1
    renderer.boundaryEnhancementGradientBias = 0
    renderer.silhouetteEnhancement = FALSE
    renderer.silhouetteEnhancementExponent = 1
    renderer.silhouetteEnhancementFactor = 1
    renderer.toneShading = FALSE
    renderer.toneShadingWarmColor = "0.67451000213623 0.533333003520966 0.141176000237465"
    renderer.toneShadingColdColor = "0 0 0.400000005960464"
    renderer.toneShadingWarmDiffuse = 0.60000002
    renderer.toneShadingColdDiffuse = 0.2
    renderer.toneShadingAngle = 45
    renderer.materialAmbient = 0.60000002
    renderer.materialDiffuse = 1
    renderer.materialSpecular = 1
    renderer.materialSpecularity = 32
    renderer.light1Enabled = TRUE
    renderer.light1DiffuseIntensity = 1
    renderer.light1SpecularIntensity = 1
    renderer.light1Color = "1 1 1"
    renderer.light1PolarPhi = 45
    renderer.light1PolarRho = 0
    renderer.light2Enabled = FALSE
    renderer.light2DiffuseIntensity = 1
    renderer.light2SpecularIntensity = 1
    renderer.light2Color = "1 1 1"
    renderer.light2PolarPhi = 0
    renderer.light2PolarRho = 0
    renderer.light3Enabled = FALSE
    renderer.light3DiffuseIntensity = 1
    renderer.light3SpecularIntensity = 1
    renderer.light3Color = "1 1 1"
    renderer.light3PolarPhi = -45
    renderer.light3PolarRho = 0
    renderer.sizeOutputX = 128
    renderer.sizeOutputY = 128
    renderer.sizeOutputZ = 128
    renderer.subVolumeStartX = 0
    renderer.subVolumeStartY = 0
    renderer.subVolumeStartZ = 0
    renderer.subVolumeEndX = 128
    renderer.subVolumeEndY = 128
    renderer.subVolumeEndZ = 128
    clip.hideGeometry = FALSE
    clip.on = FALSE
    clip.left = FALSE
    clip.right = FALSE
    clip.top = FALSE
    clip.bottom = FALSE
    clip.rear = FALSE
    clip.front = FALSE
    clip.translation0 = "1 0 0"
    clip.translation1 = "-1 0 0"
    clip.translation2 = "0 1 0"
    clip.translation3 = "0 -1 0"
    clip.translation4 = "0 0 1"
    clip.translation5 = "0 0 -1"
    clip.rotation0 = "0 0 0.999999940395355 1.57079994678497"
    clip.rotation1 = "0 0 -0.999999940395355 1.57079994678497"
    clip.rotation2 = "0 0 -1 3.1415901184082"
    clip.rotation3 = "0 0 1 0"
    clip.rotation4 = "-0.999999940395355 0 0 1.57079994678497"
    clip.rotation5 = "0.999999940395355 0 0 1.57079994678497"
  }
}
module IsoSurface {
  internal  {
    frame = "1204 -37 128 56"
    moduleGroupName = "Exercise 2.1"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "1397 139 432 336"
        sizeHint = "432 336"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = IsoSurface
    isoValue = 1
    quality = 1
    useInterpolation = FALSE
    useSmoothing = FALSE
    smoothingPasses = 5
    smoothingFactor = 0.2
    usePolygonReduction = FALSE
    targetReduction = 70
    autoUpdate = TRUE
    autoApply = TRUE
    selectedTab = 0
  }
}
module Switch {
  internal  {
    frame = "964 87 144 80"
    moduleGroupName = "Exercise 2.1"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "826 543 269 68"
        sizeHint = "269 68"
        wasOpen = no
      }
      window _automatic {
        geometry = "1146 346 500 600"
        sizeHint = "260 440"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = Switch2D3D
    currentInput = 1
    numberOfInputs = 5
  }
}
connections  {
  View2D4.inImage = Switch2D3D.output0
  View3D.inInvPreLUT = IsoSurface.outScene
  IsoSurface.inImage = Switch2D3D.output0
  Switch2D3D.input0 = CircleDrawer.output0
  Switch2D3D.input1 = SphereDrawer.output0
}
networkModel  {
  parentItems  {
    0  {
      MLABNetworkModelItem MLABNetworkModelItemGroup {
        uniqueId = 21
        objectName = "Exercise 2.1"
        parentUniqueId = 0
        color  {
          r = 45
          g = 226
          b = 226
          a = 40
        }
      }
    }
  }
}
